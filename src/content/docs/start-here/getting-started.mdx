---
title: Getting Started with RBAC
description: Step-by-step instructions for installing and running Kessel with your first managed and access controlled resource.
---

import { Aside, Badge, Card, CardGrid, LinkButton, Steps, Tabs, TabItem, Code } from '@astrojs/starlight/components';
import CodeExamples from 'src/components/CodeExamples.astro';

export const gettingStartedExamples = import.meta.glob('/src/examples/getting-started/example.*', { query: '?raw', eager: true, import: 'default' });

import commonRepresentation from 'src/examples/document/common_representation.json?raw';
import documentConfig from 'src/examples/document/config.yaml?raw';
import driveConfig from 'src/examples/document/reporters/drive/config.yaml?raw';
import driveHost from 'src/examples/document/reporters/drive/document.json?raw';
import driveSchema from 'src/examples/drive.ksl?raw';
import rbacSchema from 'src/examples/rbac.ksl?raw';
import kesselSchema from 'src/examples/kessel.ksl?raw';
import schemaZed from 'src/examples/schema.zed?raw';
import createRoleScript from 'src/examples/scripts/create-role.sh?raw';
import createRoleBindingScript from 'src/examples/scripts/create-role-binding.sh?raw';

export const createFile = (path, content) => `cat > ${path} << 'EOF'\n${content.trim()}\nEOF`;

**This tutorial walks you through setting up Kessel from scratch with a basic document management example.**
You'll learn how to configure schemas, set up RBAC permissions, install client libraries, 
and implement both resource reporting and access control using Kessel's APIs across multiple programming languages.

<Aside type="tip" title="Tip: Insights migration guide">
If you are migrating an existing Red Hat Insights application to Kessel, follow [Migrate from RBAC v1 to RBAC v2](/docs/building-with-kessel/how-to/migrate-from-rbac-v1-to-v2/) which is a guide that will walk you through all the steps of this specific use-case.
</Aside>

<Aside type="caution" title="Under Construction">Many aspects of Kessel are under construction, and this guide contains various workarounds and temporary solutions. 
Take a look at the [roadmap](#next-steps-and-roadmap) to learn more about where we're going.</Aside>

## Quick start


### Prerequisites

Let's get some prerequisites out of the way. These are temporary solutions, so don't worry about them too much.

<Steps>
1. We need a schema compiler.

    <Tabs>
      <TabItem label="Install via go install (recommended)">
        Install the KSL compiler directly from GitHub:

        ```bash
        go install github.com/project-kessel/ksl-schema-language/cmd/ksl@latest
        ```
      </TabItem>
      <TabItem label="Build from source">
        Alternatively, you can clone the repository and build locally:

        ```bash
        git clone https://github.com/project-kessel/ksl-schema-language.git
        cd ksl-schema-language
        make build
        ```
      </TabItem>
    </Tabs>

    Ensure `ksl` is in your `$PATH`, or adjust the path in the scripts below.

2. We need gRPCurl to perform some setup operations. gRPCurl is like curl, but for gRPC.

    <Tabs>
      <TabItem label="Go">
        ```bash
        go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest
        ```
      </TabItem>
      <TabItem label="Homebrew">
        ```bash
        brew install grpcurl
        ```
      </TabItem>
      <TabItem label="Other">
        See <a href="https://github.com/fullstorydev/grpcurl#installation" target="_blank" rel="noopener noreferrer">the grpcurl docs</a> for additional installation methods including Snap, Docker, and prebuilt binaries.
      </TabItem>
    </Tabs>

3. We need a clean working directory for some config files. If you don't have one already, create one and change to it now.

    ```bash
    mkdir -p kessel-getting-started
    cd kessel-getting-started
    ```

4. Some built-in schemas need to be configured manually for now. We'll talk more about schemas in the next section.

    <Code code={createFile('kessel.ksl', kesselSchema)} lang="bash" />

    <Code code={createFile('rbac.ksl', rbacSchema)} lang="bash" />

</Steps>

### Configure Resources

Now the interesting part. To protect and share your application's <i>resources</i>, you first have to configure resource _schema_.

The following is an example of a drive like schema as described in [Understanding Kessel](../understanding-kessel).
It will consistent of a simple document which is organized into Kessel's Workspaces.
It will have assignable permissions which leverage the common Kessel RBAC model.


<Steps>
1. **First we have to tell Kessel about the resource.** We include its attributes and relationships, which are used for access control.

    ```bash
    mkdir -p document/reporters/drive
    ```

    We configure a "document" resource, which has one <i>reporter</i> called "drive".

    <Code code={createFile('document/config.yaml', documentConfig)} lang="bash" />

    Documents have a "common" <i>representation</i> (JSON data). Common representation is "common" regardless of the reporter.
    Here we configure the common representation schema.
    The workspace is common, because a document is always in a single workspace,
    regardless of how many reporters there are. 

    <Code code={createFile('document/common_representation.json', commonRepresentation)} lang="bash" />

    Reporters also have representations specific to their own state.
    Here we configure the "drive" reporter and its document representation schema.

    <Code code={createFile('document/reporters/drive/config.yaml', driveConfig)} lang="bash" />

    <Code code={createFile('document/reporters/drive/document.json', driveHost)} lang="bash" />

    And finally we configure permissions.

    <Code code={createFile('drive.ksl', driveSchema)} lang="bash" />

2. **Compile to [SpiceDB](https://authzed.com/docs/spicedb/getting-started/discovering-spicedb) schema**.

    We installed the `ksl` schema compiler earlier. Use it now to compile the schemas:

    ```bash
    ksl kessel.ksl rbac.ksl drive.ksl
    ```

    This will generate a `schema.zed` file in the current directory.
    <details>
        <summary>Example generated <code>schema.zed</code> file</summary>

        <Code code={schemaZed} lang="text" title="schema.zed" />
    </details>
</Steps>

### Install and run Kessel

<Tabs>
  <TabItem label="Docker compose">
    <Steps>
    1. **Start Kessel Inventory**. Inventory is the service that stores the resources and their relationships.

        ```bash
        git clone git@github.com:project-kessel/inventory-api.git
        cd inventory-api
        cp -r ../document data/schema/resources/
        # preload the schema cache with the document resource
        go run main.go preload-schema
        make inventory-up-relations-ready
        ```

    2. **Start Relations and SpiceDB**. These form the underlying relationship storage and query engine based on relationship-based access control.

        ```bash
        git clone git@github.com:project-kessel/relations-api.git
        cd relations-api
        cp ../schema.zed deploy/schema.zed
        make relations-api-up
        ```

        <Aside type="tip">
        If you modify your schema, run `make relations-api-down`, then copy the updated `schema.zed` as above and run `make relations-api-up` again.
        </Aside>
    </Steps>

  </TabItem>
  
  <TabItem label="bonfire">
    <Aside title="Red Hatter?">
    TODO: If you need information on ephemeral cluster access, go here.
    </Aside>
    <Steps>
    1. Start Kessel Inventory

        ```bash
        bonfire deploy kessel -C kessel-inventory
        ```
        
    2. Load Schema

        ```bash
        # create configmap from the schema.zed file we created earlier
        oc create configmap spicedb-schema --dry-run=client --from-file=schema.zed -o yaml > spicedb-schema-configmap.yaml
        # apply the configmap
        oc apply -f spicedb-schema-configmap.yaml
        ```
    
    3. Fetch the API URL and Credentials

        ```bash
        bonfire namespace describe
        ```
    4. Enable port forwarding to Kessel Inventory 

        ```bash
        oc port-forward svc/kessel-inventory-api <your local port>:9000 -n <Name of current project from step 3> 
        oc port-forward svc/kessel-relations-api <your local port>:9000 -n <Name of current project from step 3> 
        ```
        
    </Steps>
  </TabItem>
</Tabs>

### Set up access with RBAC

Now Kessel is running. You configured the "built-in" RBAC schemas in prerequisites.
Then you configured a document resource and extended RBAC resources like <i>role</i> and <i>workspace</i> with relevant permissions.

For a user to get access, three things need to come together:

1. One or more permissions. These are aggregated into a role.
2. A resource. These can be aggregated into a workspace (or other resources as defined by schema).
3. A subject (e.g. a user). These can be aggregated into a group.

The union of these three things is a <i>role binding</i>. So for our next step, we will create a role to group together some permissions.
Then, we'll create a role binding by combining a **role** (the one we just created), a **resource** (some workspace), and a **subject** (some user).


This results in that user having the access described by the role to that workspace, and any documents with a "workspace" relation to it. 

<Steps>
1. **Create a role**

    A role defines a set of permissions. Edit the `ROLE_NAME` and `PERMISSIONS` variables to customize, then run the script.

    <Code code={createRoleScript} lang="bash" frame="terminal" />

2. **Create a role binding**

    A role binding grants a user access to a role for a specific resource (e.g., a workspace).
    Edit the `ROLE_NAME`, `USER_ID`, and `RESOURCE_ID` variables, then run the script.
    The binding ID is auto-generated from these inputs.

    <Code code={createRoleBindingScript} lang="bash" frame="terminal" />

</Steps>

### Setting up your environment

Kessel is configured and access is granted at the workspace level. Now onto your code and your resources.

We'll start by setting up a client you can use to interact with Kessel. We have SDKs for many popular languages, or you can use the raw API with your favorite tool.

<Steps>
1. **Install dependencies.**

    <Tabs syncKey="language">
      <TabItem label="curl">
        No SDK installation required. Just ensure `curl` is available:
        ```bash
        curl --version
        ```
      </TabItem>
      <TabItem label="grpcurl">
        If you followed along with [Prerequisites](#prerequisites), you're good to go.
      </TabItem>
      <TabItem label="Python">
        ```bash
        pip install kessel-sdk
        ```
      </TabItem>
      <TabItem label="Go">
        ```bash
        go get github.com/project-kessel/kessel-sdk-go
        ```
      </TabItem>
      <TabItem label="TypeScript">
        ```bash
        npm install @project-kessel/kessel-sdk
        ```
      </TabItem>
      <TabItem label="Ruby">
        ```bash
        gem install kessel-sdk
        ```
      </TabItem>
      <TabItem label="Java">
        <Tabs>
          <TabItem label="Maven">
            ```xml
            <dependency>
              <groupId>io.grpc</groupId>
              <artifactId>grpc-netty-shaded</artifactId>
            </dependency>
            <dependency>
              <groupId>org.project-kessel</groupId>
              <artifactId>kessel-sdk</artifactId>
              <version>1.0.0</version>
            </dependency>
            ```
          </TabItem>
          <TabItem label="Gradle">
            ```groovy
            dependencies {
              implementation 'io.grpc:grpc-netty-shaded'
              implementation "org.project-kessel:kessel-sdk:1.0.0"
            }
            ```
          </TabItem>
        </Tabs>
      </TabItem>
    </Tabs>

2. **Configure a client.**
    <CodeExamples files={gettingStartedExamples} regions="setup" />
</Steps>

### Reporting resources

Before you can check access about a resource, Kessel needs to know about it. 
Kessel learns about resources by <i>reporting</i> them.

In this example, the document resource is reported which includes its relationship to a workspace.
This inherits the access granted at at the workspace level, as defined by the document schema.

<CodeExamples files={gettingStartedExamples} regions="report" />

### Checking permissions

Once Kessel knows about a resource (and its relationships), you can check access by virtue of checking if the user has an expected <i>relationship</i> to the resource, as defined by your schema.

<CodeExamples files={gettingStartedExamples} regions="check" />

### Complete example

<CodeExamples files={gettingStartedExamples} />

## Next steps and roadmap

### Exercises

Try to experiment with the schema and relationships. Can you...

- Create a new role?
- Assign that role to a user?
- Add a new permission to the document?

### How to contribute

We're open to contributions! Check us out on GitHub at [project-kessel](https://github.com/project-kessel).

### Where are we going?

| Feature                      | Today                                                                                       | Roadmap / What's Next                                                                              |
|------------------------------|---------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|
| **Schema Language**          | Use multiple files and languages for schema, with overlap and duplicated information        | Unify all these into a single schema language—no duplication or repeated information               |
| **Configuration Method**     | Edit schema and config via files                                                            | Configure everything at runtime via an API                                                         |
| **RBAC Management**          | Use temporary scripts or the pre-Kessel RBAC v1 API                                         | Use an RBAC management API (v2) to encapsulate access grants and workspace management              |
| **Services to Run**          | Must run the Relations API separately alongside Inventory and SpiceDB                       | Relations API will be merged with Inventory—just run Inventory and SpiceDB                         |
